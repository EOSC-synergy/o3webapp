/* tslint:disable */
/* eslint-disable */
/**
 * Swagger REST API for O3as
 * This is **O3as REST API** based on the OpenAPI specification and leveraging Swagger UI for the [Ozone assessment service](https://o3as.data.kit.edu).  For the detailed documentation, please, visit [O3as documention](https://o3as.readthedocs.io).  **By using our service you agree to the [Terms of Use](https://o3as.data.kit.edu/policies/terms-of-use.html)** 
 *
 * The version of the OpenAPI document: 0.8.4
 * Contact: o3as-support@lists.kit.edu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiInfo
 */
export interface ApiInfo {
    /**
     * 
     * @type {string}
     * @memberof ApiInfo
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInfo
     */
    'author-email': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInfo
     */
    'home-page': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInfo
     */
    'license': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInfo
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInfo
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ModelInfo
 */
export interface ModelInfo {
    /**
     * 
     * @type {string}
     * @memberof ModelInfo
     */
    'legalinfo': string;
    /**
     * 
     * @type {string}
     * @memberof ModelInfo
     */
    'model': string;
    /**
     * 
     * @type {ModelInfoPlot}
     * @memberof ModelInfo
     */
    'tco3_zm'?: ModelInfoPlot;
    /**
     * 
     * @type {ModelInfoPlot}
     * @memberof ModelInfo
     */
    'tco3_return'?: ModelInfoPlot;
    /**
     * 
     * @type {ModelInfoPlot}
     * @memberof ModelInfo
     */
    'vmro3_zm'?: ModelInfoPlot;
}
/**
 * 
 * @export
 * @interface ModelInfoPlot
 */
export interface ModelInfoPlot {
    /**
     * 
     * @type {ModelInfoPlotStyle}
     * @memberof ModelInfoPlot
     */
    'plotstyle': ModelInfoPlotStyle;
    /**
     * 
     * @type {boolean}
     * @memberof ModelInfoPlot
     */
    'isdata': boolean;
    /**
     * 
     * @type {object}
     * @memberof ModelInfoPlot
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface ModelInfoPlotStyle
 */
export interface ModelInfoPlotStyle {
    /**
     * 
     * @type {string}
     * @memberof ModelInfoPlotStyle
     */
    'color': ModelInfoPlotStyleColorEnum;
    /**
     * 
     * @type {string}
     * @memberof ModelInfoPlotStyle
     */
    'linestyle': ModelInfoPlotStyleLinestyleEnum;
    /**
     * 
     * @type {string}
     * @memberof ModelInfoPlotStyle
     */
    'marker': ModelInfoPlotStyleMarkerEnum;
}

export const ModelInfoPlotStyleColorEnum = {
    Black: 'black',
    Gray: 'gray',
    Red: 'red',
    Chocolate: 'chocolate',
    Orange: 'orange',
    Gold: 'gold',
    Olive: 'olive',
    Green: 'green',
    Lime: 'lime',
    Lightseagreen: 'lightseagreen',
    Teal: 'teal',
    Deepskyblue: 'deepskyblue',
    Navy: 'navy',
    Blue: 'blue',
    Purple: 'purple',
    Magenta: 'magenta'
} as const;

export type ModelInfoPlotStyleColorEnum = typeof ModelInfoPlotStyleColorEnum[keyof typeof ModelInfoPlotStyleColorEnum];
export const ModelInfoPlotStyleLinestyleEnum = {
    Solid: 'solid',
    Dotted: 'dotted',
    Dashed: 'dashed',
    Dashdot: 'dashdot',
    None: 'none'
} as const;

export type ModelInfoPlotStyleLinestyleEnum = typeof ModelInfoPlotStyleLinestyleEnum[keyof typeof ModelInfoPlotStyleLinestyleEnum];
export const ModelInfoPlotStyleMarkerEnum = {
    Period: '.',
    O: 'o',
    Plus: '+',
    X: 'x',
    V: 'v',
    Caret: '^',
    S: 's',
    Star: '*',
    D: 'D',
    Empty: ''
} as const;

export type ModelInfoPlotStyleMarkerEnum = typeof ModelInfoPlotStyleMarkerEnum[keyof typeof ModelInfoPlotStyleMarkerEnum];

/**
 * 
 * @export
 * @interface ModelPlotStyle
 */
export interface ModelPlotStyle {
    /**
     * 
     * @type {string}
     * @memberof ModelPlotStyle
     */
    'model': string;
    /**
     * 
     * @type {ModelPlotStylePlot}
     * @memberof ModelPlotStyle
     */
    'tco3_zm': ModelPlotStylePlot;
    /**
     * 
     * @type {ModelPlotStylePlot}
     * @memberof ModelPlotStyle
     */
    'tco3_return': ModelPlotStylePlot;
    /**
     * 
     * @type {ModelPlotStylePlot}
     * @memberof ModelPlotStyle
     */
    'vmro3_zm': ModelPlotStylePlot;
}
/**
 * 
 * @export
 * @interface ModelPlotStylePlot
 */
export interface ModelPlotStylePlot {
    /**
     * 
     * @type {ModelInfoPlotStyle}
     * @memberof ModelPlotStylePlot
     */
    'plotstyle': ModelInfoPlotStyle;
}
/**
 * 
 * @export
 * @interface O3Data
 */
export interface O3Data {
    /**
     * 
     * @type {string}
     * @memberof O3Data
     */
    'legalinfo'?: string;
    /**
     * 
     * @type {string}
     * @memberof O3Data
     */
    'model'?: string;
    /**
     * 
     * @type {object}
     * @memberof O3Data
     */
    'plotstyle'?: object;
    /**
     * 
     * @type {Array<string>}
     * @memberof O3Data
     */
    'x'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof O3Data
     */
    'y'?: Array<number>;
}
/**
 * 
 * @export
 * @interface Plot
 */
export interface Plot {
    /**
     * 
     * @type {string}
     * @memberof Plot
     */
    'legalinfo': string;
    /**
     * 
     * @type {string}
     * @memberof Plot
     */
    'model': string;
    /**
     * 
     * @type {PlotPlotstyle}
     * @memberof Plot
     */
    'plotstyle': PlotPlotstyle;
    /**
     * 
     * @type {Array<string>}
     * @memberof Plot
     */
    'x': Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Plot
     */
    'y': Array<number>;
}
/**
 * 
 * @export
 * @interface PlotPlotstyle
 */
export interface PlotPlotstyle {
    /**
     * 
     * @type {number}
     * @memberof PlotPlotstyle
     */
    'linewidth'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlotPlotstyle
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlotPlotstyle
     */
    'color': PlotPlotstyleColorEnum;
    /**
     * 
     * @type {string}
     * @memberof PlotPlotstyle
     */
    'linestyle': PlotPlotstyleLinestyleEnum;
    /**
     * 
     * @type {string}
     * @memberof PlotPlotstyle
     */
    'marker': PlotPlotstyleMarkerEnum;
}

export const PlotPlotstyleColorEnum = {
    Black: 'black',
    Gray: 'gray',
    Red: 'red',
    Chocolate: 'chocolate',
    Orange: 'orange',
    Gold: 'gold',
    Olive: 'olive',
    Green: 'green',
    Lime: 'lime',
    Lightseagreen: 'lightseagreen',
    Teal: 'teal',
    Deepskyblue: 'deepskyblue',
    Navy: 'navy',
    Blue: 'blue',
    Purple: 'purple',
    Magenta: 'magenta'
} as const;

export type PlotPlotstyleColorEnum = typeof PlotPlotstyleColorEnum[keyof typeof PlotPlotstyleColorEnum];
export const PlotPlotstyleLinestyleEnum = {
    Solid: 'solid',
    Dotted: 'dotted',
    Dashed: 'dashed',
    Dashdot: 'dashdot',
    None: 'none'
} as const;

export type PlotPlotstyleLinestyleEnum = typeof PlotPlotstyleLinestyleEnum[keyof typeof PlotPlotstyleLinestyleEnum];
export const PlotPlotstyleMarkerEnum = {
    Period: '.',
    O: 'o',
    Plus: '+',
    X: 'x',
    V: 'v',
    Caret: '^',
    S: 's',
    Star: '*',
    D: 'D',
    Empty: ''
} as const;

export type PlotPlotstyleMarkerEnum = typeof PlotPlotstyleMarkerEnum[keyof typeof PlotPlotstyleMarkerEnum];

/**
 * 
 * @export
 * @interface PlotPlotstyleAllOf
 */
export interface PlotPlotstyleAllOf {
    /**
     * 
     * @type {number}
     * @memberof PlotPlotstyleAllOf
     */
    'linewidth'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlotPlotstyleAllOf
     */
    'label'?: string;
}

/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Information about the API (o3api metadata)
         * @summary Returns information about the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetApiInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/apiinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration)
    return {
        /**
         * Information about the API (o3api metadata)
         * @summary Returns information about the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async o3apiApiGetApiInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.o3apiApiGetApiInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiApiFp(configuration)
    return {
        /**
         * Information about the API (o3api metadata)
         * @summary Returns information about the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetApiInfo(options?: any): AxiosPromise<ApiInfo> {
            return localVarFp.o3apiApiGetApiInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
    /**
     * Information about the API (o3api metadata)
     * @summary Returns information about the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public o3apiApiGetApiInfo(options?: AxiosRequestConfig) {
        return ApiApiFp(this.configuration).o3apiApiGetApiInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataApi - axios parameter creator
 * @export
 */
export const DataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Raw data to be processed for building tco3_return plot
         * @summary Returns raw data for tco3_return
         * @param {Array<string>} models Name(s) of model(s) (dataset-model)
         * @param {number} [begin] Year to start data scanning from
         * @param {number} [end] Year to finish data scanning
         * @param {Array<number>} [month] Month(s) to select, if not a whole year
         * @param {number} [latMin] Latitude (min) to define the range (-90..90)
         * @param {number} [latMax] Latitude (max) to define the range (-90..90)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetDataTco3Return: async (models: Array<string>, begin?: number, end?: number, month?: Array<number>, latMin?: number, latMax?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'models' is not null or undefined
            assertParamExists('o3apiApiGetDataTco3Return', 'models', models)
            const localVarPath = `/data/tco3_return`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (begin !== undefined) {
                localVarQueryParameter['begin'] = begin;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (month) {
                localVarQueryParameter['month'] = month.join(COLLECTION_FORMATS.csv);
            }

            if (latMin !== undefined) {
                localVarQueryParameter['lat_min'] = latMin;
            }

            if (latMax !== undefined) {
                localVarQueryParameter['lat_max'] = latMax;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(models, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Raw data to be processed for building tco3_zm plot
         * @summary Returns raw data for tco3_zm
         * @param {Array<string>} models Name(s) of model(s) (dataset-model)
         * @param {number} [begin] Year to start data scanning from
         * @param {number} [end] Year to finish data scanning
         * @param {Array<number>} [month] Month(s) to select, if not a whole year
         * @param {number} [latMin] Latitude (min) to define the range (-90..90)
         * @param {number} [latMax] Latitude (max) to define the range (-90..90)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetDataTco3Zm: async (models: Array<string>, begin?: number, end?: number, month?: Array<number>, latMin?: number, latMax?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'models' is not null or undefined
            assertParamExists('o3apiApiGetDataTco3Zm', 'models', models)
            const localVarPath = `/data/tco3_zm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (begin !== undefined) {
                localVarQueryParameter['begin'] = begin;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (month) {
                localVarQueryParameter['month'] = month.join(COLLECTION_FORMATS.csv);
            }

            if (latMin !== undefined) {
                localVarQueryParameter['lat_min'] = latMin;
            }

            if (latMax !== undefined) {
                localVarQueryParameter['lat_max'] = latMax;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(models, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of plot types with the available raw data
         * @summary Returns a list of plot types with the available raw data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetDataTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataApiAxiosParamCreator(configuration)
    return {
        /**
         * Raw data to be processed for building tco3_return plot
         * @summary Returns raw data for tco3_return
         * @param {Array<string>} models Name(s) of model(s) (dataset-model)
         * @param {number} [begin] Year to start data scanning from
         * @param {number} [end] Year to finish data scanning
         * @param {Array<number>} [month] Month(s) to select, if not a whole year
         * @param {number} [latMin] Latitude (min) to define the range (-90..90)
         * @param {number} [latMax] Latitude (max) to define the range (-90..90)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async o3apiApiGetDataTco3Return(models: Array<string>, begin?: number, end?: number, month?: Array<number>, latMin?: number, latMax?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<O3Data>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.o3apiApiGetDataTco3Return(models, begin, end, month, latMin, latMax, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Raw data to be processed for building tco3_zm plot
         * @summary Returns raw data for tco3_zm
         * @param {Array<string>} models Name(s) of model(s) (dataset-model)
         * @param {number} [begin] Year to start data scanning from
         * @param {number} [end] Year to finish data scanning
         * @param {Array<number>} [month] Month(s) to select, if not a whole year
         * @param {number} [latMin] Latitude (min) to define the range (-90..90)
         * @param {number} [latMax] Latitude (max) to define the range (-90..90)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async o3apiApiGetDataTco3Zm(models: Array<string>, begin?: number, end?: number, month?: Array<number>, latMin?: number, latMax?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<O3Data>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.o3apiApiGetDataTco3Zm(models, begin, end, month, latMin, latMax, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List of plot types with the available raw data
         * @summary Returns a list of plot types with the available raw data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async o3apiApiGetDataTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.o3apiApiGetDataTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataApiFp(configuration)
    return {
        /**
         * Raw data to be processed for building tco3_return plot
         * @summary Returns raw data for tco3_return
         * @param {Array<string>} models Name(s) of model(s) (dataset-model)
         * @param {number} [begin] Year to start data scanning from
         * @param {number} [end] Year to finish data scanning
         * @param {Array<number>} [month] Month(s) to select, if not a whole year
         * @param {number} [latMin] Latitude (min) to define the range (-90..90)
         * @param {number} [latMax] Latitude (max) to define the range (-90..90)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetDataTco3Return(models: Array<string>, begin?: number, end?: number, month?: Array<number>, latMin?: number, latMax?: number, options?: any): AxiosPromise<Array<O3Data>> {
            return localVarFp.o3apiApiGetDataTco3Return(models, begin, end, month, latMin, latMax, options).then((request) => request(axios, basePath));
        },
        /**
         * Raw data to be processed for building tco3_zm plot
         * @summary Returns raw data for tco3_zm
         * @param {Array<string>} models Name(s) of model(s) (dataset-model)
         * @param {number} [begin] Year to start data scanning from
         * @param {number} [end] Year to finish data scanning
         * @param {Array<number>} [month] Month(s) to select, if not a whole year
         * @param {number} [latMin] Latitude (min) to define the range (-90..90)
         * @param {number} [latMax] Latitude (max) to define the range (-90..90)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetDataTco3Zm(models: Array<string>, begin?: number, end?: number, month?: Array<number>, latMin?: number, latMax?: number, options?: any): AxiosPromise<Array<O3Data>> {
            return localVarFp.o3apiApiGetDataTco3Zm(models, begin, end, month, latMin, latMax, options).then((request) => request(axios, basePath));
        },
        /**
         * List of plot types with the available raw data
         * @summary Returns a list of plot types with the available raw data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetDataTypes(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.o3apiApiGetDataTypes(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
    /**
     * Raw data to be processed for building tco3_return plot
     * @summary Returns raw data for tco3_return
     * @param {Array<string>} models Name(s) of model(s) (dataset-model)
     * @param {number} [begin] Year to start data scanning from
     * @param {number} [end] Year to finish data scanning
     * @param {Array<number>} [month] Month(s) to select, if not a whole year
     * @param {number} [latMin] Latitude (min) to define the range (-90..90)
     * @param {number} [latMax] Latitude (max) to define the range (-90..90)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public o3apiApiGetDataTco3Return(models: Array<string>, begin?: number, end?: number, month?: Array<number>, latMin?: number, latMax?: number, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).o3apiApiGetDataTco3Return(models, begin, end, month, latMin, latMax, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Raw data to be processed for building tco3_zm plot
     * @summary Returns raw data for tco3_zm
     * @param {Array<string>} models Name(s) of model(s) (dataset-model)
     * @param {number} [begin] Year to start data scanning from
     * @param {number} [end] Year to finish data scanning
     * @param {Array<number>} [month] Month(s) to select, if not a whole year
     * @param {number} [latMin] Latitude (min) to define the range (-90..90)
     * @param {number} [latMax] Latitude (max) to define the range (-90..90)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public o3apiApiGetDataTco3Zm(models: Array<string>, begin?: number, end?: number, month?: Array<number>, latMin?: number, latMax?: number, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).o3apiApiGetDataTco3Zm(models, begin, end, month, latMin, latMax, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of plot types with the available raw data
     * @summary Returns a list of plot types with the available raw data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public o3apiApiGetDataTypes(options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).o3apiApiGetDataTypes(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ModelsApi - axios parameter creator
 * @export
 */
export const ModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Detailed information about a model
         * @summary Returns detailed information about a model
         * @param {string} model model name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetModelDetail: async (model: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'model' is not null or undefined
            assertParamExists('o3apiApiGetModelDetail', 'model', model)
            const localVarPath = `/models/{model}`
                .replace(`{${"model"}}`, encodeURIComponent(String(model)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of available models
         * @summary Returns a list of available models
         * @param {string} [ptype] Plot type (tco3_return, tco3_zm, vmro3_zm)
         * @param {string} [select] Select models according to the {select} pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetModelsList: async (ptype?: string, select?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ptype !== undefined) {
                localVarQueryParameter['ptype'] = ptype;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Plot styles for selected models and plot type
         * @summary Returns plot styles for models
         * @param {string} [ptype] Plot type (tco3_return, tco3_zm, vmro3_zm)
         * @param {Array<string>} [models] Name(s) of model(s) (dataset-model)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetPlotStyle: async (ptype?: string, models?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/models/plotstyle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ptype !== undefined) {
                localVarQueryParameter['ptype'] = ptype;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(models, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelsApi - functional programming interface
 * @export
 */
export const ModelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Detailed information about a model
         * @summary Returns detailed information about a model
         * @param {string} model model name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async o3apiApiGetModelDetail(model: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.o3apiApiGetModelDetail(model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List of available models
         * @summary Returns a list of available models
         * @param {string} [ptype] Plot type (tco3_return, tco3_zm, vmro3_zm)
         * @param {string} [select] Select models according to the {select} pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async o3apiApiGetModelsList(ptype?: string, select?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.o3apiApiGetModelsList(ptype, select, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Plot styles for selected models and plot type
         * @summary Returns plot styles for models
         * @param {string} [ptype] Plot type (tco3_return, tco3_zm, vmro3_zm)
         * @param {Array<string>} [models] Name(s) of model(s) (dataset-model)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async o3apiApiGetPlotStyle(ptype?: string, models?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelPlotStyle>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.o3apiApiGetPlotStyle(ptype, models, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ModelsApi - factory interface
 * @export
 */
export const ModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelsApiFp(configuration)
    return {
        /**
         * Detailed information about a model
         * @summary Returns detailed information about a model
         * @param {string} model model name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetModelDetail(model: string, options?: any): AxiosPromise<ModelInfo> {
            return localVarFp.o3apiApiGetModelDetail(model, options).then((request) => request(axios, basePath));
        },
        /**
         * List of available models
         * @summary Returns a list of available models
         * @param {string} [ptype] Plot type (tco3_return, tco3_zm, vmro3_zm)
         * @param {string} [select] Select models according to the {select} pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetModelsList(ptype?: string, select?: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.o3apiApiGetModelsList(ptype, select, options).then((request) => request(axios, basePath));
        },
        /**
         * Plot styles for selected models and plot type
         * @summary Returns plot styles for models
         * @param {string} [ptype] Plot type (tco3_return, tco3_zm, vmro3_zm)
         * @param {Array<string>} [models] Name(s) of model(s) (dataset-model)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetPlotStyle(ptype?: string, models?: Array<string>, options?: any): AxiosPromise<Array<ModelPlotStyle>> {
            return localVarFp.o3apiApiGetPlotStyle(ptype, models, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelsApi - object-oriented interface
 * @export
 * @class ModelsApi
 * @extends {BaseAPI}
 */
export class ModelsApi extends BaseAPI {
    /**
     * Detailed information about a model
     * @summary Returns detailed information about a model
     * @param {string} model model name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public o3apiApiGetModelDetail(model: string, options?: AxiosRequestConfig) {
        return ModelsApiFp(this.configuration).o3apiApiGetModelDetail(model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of available models
     * @summary Returns a list of available models
     * @param {string} [ptype] Plot type (tco3_return, tco3_zm, vmro3_zm)
     * @param {string} [select] Select models according to the {select} pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public o3apiApiGetModelsList(ptype?: string, select?: string, options?: AxiosRequestConfig) {
        return ModelsApiFp(this.configuration).o3apiApiGetModelsList(ptype, select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Plot styles for selected models and plot type
     * @summary Returns plot styles for models
     * @param {string} [ptype] Plot type (tco3_return, tco3_zm, vmro3_zm)
     * @param {Array<string>} [models] Name(s) of model(s) (dataset-model)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public o3apiApiGetPlotStyle(ptype?: string, models?: Array<string>, options?: AxiosRequestConfig) {
        return ModelsApiFp(this.configuration).o3apiApiGetPlotStyle(ptype, models, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlotsApi - axios parameter creator
 * @export
 */
export const PlotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List of possible plots
         * @summary Returns a list of possible plots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetPlotTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/plots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * tco3_return plot or corresponding data points
         * @summary Builds and returns tco3_return plot
         * @param {string} refMeas Reference observational measurument
         * @param {number} refYear Reference year for the obsevational measurement
         * @param {Array<string>} models Name(s) of model(s) (dataset-model)
         * @param {Array<number>} [month] Month(s) to select, if not a whole year
         * @param {number} [latMin] Latitude (min) to define the range (-90..90)
         * @param {number} [latMax] Latitude (max) to define the range (-90..90)
         * @param {boolean} [refFillna] Select \&#39;true\&#39; to linearly interpolate missing values in the reference measurement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiPlotTco3Return: async (refMeas: string, refYear: number, models: Array<string>, month?: Array<number>, latMin?: number, latMax?: number, refFillna?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refMeas' is not null or undefined
            assertParamExists('o3apiApiPlotTco3Return', 'refMeas', refMeas)
            // verify required parameter 'refYear' is not null or undefined
            assertParamExists('o3apiApiPlotTco3Return', 'refYear', refYear)
            // verify required parameter 'models' is not null or undefined
            assertParamExists('o3apiApiPlotTco3Return', 'models', models)
            const localVarPath = `/plots/tco3_return`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (month) {
                localVarQueryParameter['month'] = month.join(COLLECTION_FORMATS.csv);
            }

            if (latMin !== undefined) {
                localVarQueryParameter['lat_min'] = latMin;
            }

            if (latMax !== undefined) {
                localVarQueryParameter['lat_max'] = latMax;
            }

            if (refMeas !== undefined) {
                localVarQueryParameter['ref_meas'] = refMeas;
            }

            if (refYear !== undefined) {
                localVarQueryParameter['ref_year'] = refYear;
            }

            if (refFillna !== undefined) {
                localVarQueryParameter['ref_fillna'] = refFillna;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(models, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * tco3_zm plot or corresponding data points
         * @summary Builds and returns tco3_zm plot
         * @param {string} refMeas Reference observational measurument
         * @param {number} refYear Reference year for the obsevational measurement
         * @param {Array<string>} models Name(s) of model(s) (dataset-model)
         * @param {number} [begin] Year to start data scanning from
         * @param {number} [end] Year to finish data scanning
         * @param {Array<number>} [month] Month(s) to select, if not a whole year
         * @param {number} [latMin] Latitude (min) to define the range (-90..90)
         * @param {number} [latMax] Latitude (max) to define the range (-90..90)
         * @param {boolean} [refFillna] Select \&#39;true\&#39; to linearly interpolate missing values in the reference measurement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiPlotTco3Zm: async (refMeas: string, refYear: number, models: Array<string>, begin?: number, end?: number, month?: Array<number>, latMin?: number, latMax?: number, refFillna?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refMeas' is not null or undefined
            assertParamExists('o3apiApiPlotTco3Zm', 'refMeas', refMeas)
            // verify required parameter 'refYear' is not null or undefined
            assertParamExists('o3apiApiPlotTco3Zm', 'refYear', refYear)
            // verify required parameter 'models' is not null or undefined
            assertParamExists('o3apiApiPlotTco3Zm', 'models', models)
            const localVarPath = `/plots/tco3_zm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (begin !== undefined) {
                localVarQueryParameter['begin'] = begin;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (month) {
                localVarQueryParameter['month'] = month.join(COLLECTION_FORMATS.csv);
            }

            if (latMin !== undefined) {
                localVarQueryParameter['lat_min'] = latMin;
            }

            if (latMax !== undefined) {
                localVarQueryParameter['lat_max'] = latMax;
            }

            if (refMeas !== undefined) {
                localVarQueryParameter['ref_meas'] = refMeas;
            }

            if (refYear !== undefined) {
                localVarQueryParameter['ref_year'] = refYear;
            }

            if (refFillna !== undefined) {
                localVarQueryParameter['ref_fillna'] = refFillna;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(models, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlotsApi - functional programming interface
 * @export
 */
export const PlotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlotsApiAxiosParamCreator(configuration)
    return {
        /**
         * List of possible plots
         * @summary Returns a list of possible plots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async o3apiApiGetPlotTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.o3apiApiGetPlotTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * tco3_return plot or corresponding data points
         * @summary Builds and returns tco3_return plot
         * @param {string} refMeas Reference observational measurument
         * @param {number} refYear Reference year for the obsevational measurement
         * @param {Array<string>} models Name(s) of model(s) (dataset-model)
         * @param {Array<number>} [month] Month(s) to select, if not a whole year
         * @param {number} [latMin] Latitude (min) to define the range (-90..90)
         * @param {number} [latMax] Latitude (max) to define the range (-90..90)
         * @param {boolean} [refFillna] Select \&#39;true\&#39; to linearly interpolate missing values in the reference measurement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async o3apiApiPlotTco3Return(refMeas: string, refYear: number, models: Array<string>, month?: Array<number>, latMin?: number, latMax?: number, refFillna?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Plot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.o3apiApiPlotTco3Return(refMeas, refYear, models, month, latMin, latMax, refFillna, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * tco3_zm plot or corresponding data points
         * @summary Builds and returns tco3_zm plot
         * @param {string} refMeas Reference observational measurument
         * @param {number} refYear Reference year for the obsevational measurement
         * @param {Array<string>} models Name(s) of model(s) (dataset-model)
         * @param {number} [begin] Year to start data scanning from
         * @param {number} [end] Year to finish data scanning
         * @param {Array<number>} [month] Month(s) to select, if not a whole year
         * @param {number} [latMin] Latitude (min) to define the range (-90..90)
         * @param {number} [latMax] Latitude (max) to define the range (-90..90)
         * @param {boolean} [refFillna] Select \&#39;true\&#39; to linearly interpolate missing values in the reference measurement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async o3apiApiPlotTco3Zm(refMeas: string, refYear: number, models: Array<string>, begin?: number, end?: number, month?: Array<number>, latMin?: number, latMax?: number, refFillna?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Plot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.o3apiApiPlotTco3Zm(refMeas, refYear, models, begin, end, month, latMin, latMax, refFillna, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlotsApi - factory interface
 * @export
 */
export const PlotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlotsApiFp(configuration)
    return {
        /**
         * List of possible plots
         * @summary Returns a list of possible plots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiGetPlotTypes(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.o3apiApiGetPlotTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * tco3_return plot or corresponding data points
         * @summary Builds and returns tco3_return plot
         * @param {string} refMeas Reference observational measurument
         * @param {number} refYear Reference year for the obsevational measurement
         * @param {Array<string>} models Name(s) of model(s) (dataset-model)
         * @param {Array<number>} [month] Month(s) to select, if not a whole year
         * @param {number} [latMin] Latitude (min) to define the range (-90..90)
         * @param {number} [latMax] Latitude (max) to define the range (-90..90)
         * @param {boolean} [refFillna] Select \&#39;true\&#39; to linearly interpolate missing values in the reference measurement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiPlotTco3Return(refMeas: string, refYear: number, models: Array<string>, month?: Array<number>, latMin?: number, latMax?: number, refFillna?: boolean, options?: any): AxiosPromise<Array<Plot>> {
            return localVarFp.o3apiApiPlotTco3Return(refMeas, refYear, models, month, latMin, latMax, refFillna, options).then((request) => request(axios, basePath));
        },
        /**
         * tco3_zm plot or corresponding data points
         * @summary Builds and returns tco3_zm plot
         * @param {string} refMeas Reference observational measurument
         * @param {number} refYear Reference year for the obsevational measurement
         * @param {Array<string>} models Name(s) of model(s) (dataset-model)
         * @param {number} [begin] Year to start data scanning from
         * @param {number} [end] Year to finish data scanning
         * @param {Array<number>} [month] Month(s) to select, if not a whole year
         * @param {number} [latMin] Latitude (min) to define the range (-90..90)
         * @param {number} [latMax] Latitude (max) to define the range (-90..90)
         * @param {boolean} [refFillna] Select \&#39;true\&#39; to linearly interpolate missing values in the reference measurement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        o3apiApiPlotTco3Zm(refMeas: string, refYear: number, models: Array<string>, begin?: number, end?: number, month?: Array<number>, latMin?: number, latMax?: number, refFillna?: boolean, options?: any): AxiosPromise<Array<Plot>> {
            return localVarFp.o3apiApiPlotTco3Zm(refMeas, refYear, models, begin, end, month, latMin, latMax, refFillna, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlotsApi - object-oriented interface
 * @export
 * @class PlotsApi
 * @extends {BaseAPI}
 */
export class PlotsApi extends BaseAPI {
    /**
     * List of possible plots
     * @summary Returns a list of possible plots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlotsApi
     */
    public o3apiApiGetPlotTypes(options?: AxiosRequestConfig) {
        return PlotsApiFp(this.configuration).o3apiApiGetPlotTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * tco3_return plot or corresponding data points
     * @summary Builds and returns tco3_return plot
     * @param {string} refMeas Reference observational measurument
     * @param {number} refYear Reference year for the obsevational measurement
     * @param {Array<string>} models Name(s) of model(s) (dataset-model)
     * @param {Array<number>} [month] Month(s) to select, if not a whole year
     * @param {number} [latMin] Latitude (min) to define the range (-90..90)
     * @param {number} [latMax] Latitude (max) to define the range (-90..90)
     * @param {boolean} [refFillna] Select \&#39;true\&#39; to linearly interpolate missing values in the reference measurement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlotsApi
     */
    public o3apiApiPlotTco3Return(refMeas: string, refYear: number, models: Array<string>, month?: Array<number>, latMin?: number, latMax?: number, refFillna?: boolean, options?: AxiosRequestConfig) {
        return PlotsApiFp(this.configuration).o3apiApiPlotTco3Return(refMeas, refYear, models, month, latMin, latMax, refFillna, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * tco3_zm plot or corresponding data points
     * @summary Builds and returns tco3_zm plot
     * @param {string} refMeas Reference observational measurument
     * @param {number} refYear Reference year for the obsevational measurement
     * @param {Array<string>} models Name(s) of model(s) (dataset-model)
     * @param {number} [begin] Year to start data scanning from
     * @param {number} [end] Year to finish data scanning
     * @param {Array<number>} [month] Month(s) to select, if not a whole year
     * @param {number} [latMin] Latitude (min) to define the range (-90..90)
     * @param {number} [latMax] Latitude (max) to define the range (-90..90)
     * @param {boolean} [refFillna] Select \&#39;true\&#39; to linearly interpolate missing values in the reference measurement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlotsApi
     */
    public o3apiApiPlotTco3Zm(refMeas: string, refYear: number, models: Array<string>, begin?: number, end?: number, month?: Array<number>, latMin?: number, latMax?: number, refFillna?: boolean, options?: AxiosRequestConfig) {
        return PlotsApiFp(this.configuration).o3apiApiPlotTco3Zm(refMeas, refYear, models, begin, end, month, latMin, latMax, refFillna, options).then((request) => request(this.axios, this.basePath));
    }
}


