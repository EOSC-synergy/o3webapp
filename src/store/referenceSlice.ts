import { createSlice } from '@reduxjs/toolkit';
import { HYDRATE } from 'next-redux-wrapper';

/**
 * The string identifying the default reference model used in the webApp
 * @category referenceSlice
 * @default "SBUV_GSFC_merged-SAT-ozone"
 */
export const DEFAULT_REF_MODEL = 'SBUV_GSFC_merged-SAT-ozone';

/**
 * The default year of the reference year
 * @category referenceSlice
 * @default 1980
 */
export const DEFAULT_REF_YEAR = 1980;

export type ReferenceState = {
    settings: {
        year: number;
        model: string;
        visible: boolean;
        isOffsetApplied: boolean;
    };
};
export type GlobalReferenceState = {
    reference: ReferenceState;
};

/**
 * The initial state of the referenceSlice defines the data structure in the
 * store. Each reference setting has its own settings i.e. title, ref Year etc.
 *
 * If you change this initial state you have to adapt the first test in the
 * corresponding test file, that tests the initial state.
 */
const initialState: ReferenceState = {
    settings: {
        year: DEFAULT_REF_YEAR,
        model: DEFAULT_REF_MODEL,
        visible: true,
        isOffsetApplied: false,
    },
};

type Payload<T> = {
    payload: T;
};

/**
 * The referenceSlice is generated by the redux toolkit. The reducers are defined here
 * and the corresponding actions are auto-generated.
 * @category referenceSlice
 * @constant {Object}
 */
const referenceSlice = createSlice({
    name: 'reference',
    initialState,
    reducers: {
        /**
         * This reducer accepts an action object returned from setYear()
         *     e.g. dispatch(setYear({year: 1980}))
         * and calculates the new state based on the action and the action
         * data given in action.payload.
         *
         * In this case the current year is set to the given year.
         *
         * @param state the current store state of: state/reference
         * @param year the new year.
         * @example dispatch(setYear({year: 1980}));
         */
        setYear(state: ReferenceState, { payload: { year } }: Payload<{ year: number }>) {
            state.settings.year = year;
        },

        /**
         * This reducer accepts an action object returned from setModel()
         *     e.g. dispatch(setModel({model: "CCMI-1_CCCma_CMAM-refC2"}))
         * and calculates the new state based on the action and the action
         * data given in action.payload.
         *
         * In this case the current model is set to the given model.
         *
         * @param state the current store state of: state/reference
         * @param model the new reference model name.
         * @example  dispatch(setModel({model: "CCMI-1_CCCma_CMAM-refC2"}));
         */
        setModel(state: ReferenceState, { payload: { model } }: Payload<{ model: string }>) {
            state.settings.model = model;
        },

        /**
         * This reducer accepts an action object returned from setVisibility()
         *     e.g. dispatch(setVisibility({visible: true}))
         * and calculates the new state based on the action and the action
         * data given in action.payload.
         *
         * In this case the current visibility is set to the given visibility.
         *
         * @param state the current store state of: state/reference
         * @param visible whether the reference line should be visible.
         * @example dispatch(setVisibility({visible: true}));
         */
        setVisibility(
            state: ReferenceState,
            { payload: { visible } }: Payload<{ visible: boolean }>
        ) {
            state.settings.visible = visible;
        },

        /**
         * This reducer accepts an action object returned from setOffsetApplied()
         *     e.g. dispatch(setOffsetApplied({isOffsetApplied: true}))
         * and calculates the new state based on the action and the action
         * data given in action.payload.
         *
         * In this case the current offset status  is set to the given offset status.
         *
         * @param {object} state the current store state of: state/reference
         * @param {object} action accepts the action returned from setOffsetApplied()
         * @param {object} action.payload the payload is an object containing the given data
         * @param {boolean} action.payload.isOffsetApplied the boolean for the offset status.
         * @example dispatch(setOffsetApplied({isOffsetApplied: true}));
         */
        setOffsetApplied(
            state: ReferenceState,
            { payload: { isOffsetApplied } }: Payload<{ isOffsetApplied: boolean }>
        ) {
            state.settings.isOffsetApplied = isOffsetApplied;
        },
    },
    extraReducers: {
        [HYDRATE]: (state: ReferenceState, action) => {
            console.log('HYDRATE', state, action.payload);
            return {
                ...state,
                ...action.payload.subject,
            };
        },
    },
});

/**
 * The here listed actions are exported and serve as an interface for
 * the view (our React components).
 */
export const { setYear, setModel, setVisibility, setOffsetApplied } = referenceSlice.actions;

/**
 * The reducer combining all reducers defined in the reference slice.
 * This has to be included in the redux store, otherwise dispatching
 * the above defined actions wouldn't trigger state updates.
 * @category referenceSlice
 * @constant {Object}
 */
export default referenceSlice.reducer;

/**
 * This selector allows components to select the current reference year
 * from the store.
 *
 * @param {object} state the global redux state
 * @returns {number} the current active reference year
 * @category referenceSlice
 * @function
 */
export const selectRefYear = (state: GlobalReferenceState) => state.reference.settings.year;

/**
 * This selector allows components to select the current reference model
 * from the store.
 *
 * @param {object} state the global redux state
 * @returns {string} the current active reference model
 * @function
 * @category referenceSlice
 */
export const selectRefModel = (state: GlobalReferenceState) => state.reference.settings.model;

/**
 * This selector allows components to select the current visibility of the reference line
 * from the store.
 *
 * @param {object} state the global redux state
 * @returns {boolean} the current visibility of the reference line.
 * @function
 * @category referenceSlice
 */
export const selectVisibility = (state: GlobalReferenceState) => state.reference.settings.visible;

/**
 * This selector allows components to select the current status of the offset
 * from the store.
 *
 * @param {object} state the global redux state
 * @returns {boolean} the current status of the offset.
 * @function
 * @category referenceSlice
 */
export const selectIsOffsetApplied = (state: GlobalReferenceState) =>
    state.reference.settings.isOffsetApplied;
